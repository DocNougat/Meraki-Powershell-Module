function Get-MerakiNetworkApplianceSecurityMalware {
<#
.SYNOPSIS
Retrieves the malware configuration and status for a Meraki network appliance.

.DESCRIPTION
Calls the Meraki Dashboard API endpoint GET /networks/{networkId}/appliance/security/malware to obtain the current malware settings for the specified Meraki network's appliance. The function authenticates using an API key supplied via the AuthToken parameter and returns the deserialized JSON response as PowerShell objects.

.PARAMETER AuthToken
The Meraki Dashboard API key used for authentication. Must be a valid API key with appropriate permissions to read network appliance settings.

.PARAMETER NetworkId
The identifier of the Meraki network to query (for example: N_1234567890). This is the networkId path parameter required by the Meraki API.

.EXAMPLE
PS> Get-MerakiNetworkApplianceSecurityMalware -AuthToken 'abcd1234efgh...' -NetworkId 'N_1234567890'
Retrieves the malware configuration for the specified network and returns a PowerShell object representing the response.

.OUTPUTS
System.Object
Returns a deserialized JSON object (PSCustomObject) representing the malware settings and policy returned by the Meraki API. The exact properties correspond to the API response schema.

.NOTES
- Requires network access to https://api.meraki.com.
- Errors from the API call are thrown to the caller; consider using try/catch when invoking this function.
- Refer to Cisco Meraki API documentation for the endpoint details: https://developer.cisco.com/meraki/api-v1/
#>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$AuthToken,
        [Parameter(Mandatory=$true)]
        [string]$NetworkId
    )
    try {
        $header = @{
            'X-Cisco-Meraki-API-Key' = $AuthToken
        }
        $response = Invoke-RestMethod -Method Get -Uri "https://api.meraki.com/api/v1/networks/$NetworkId/appliance/security/malware" -headers $header -UserAgent "MerakiPowerShellModule/1.1.3 DocNougat" -ErrorAction Stop
        return $response
    }
    catch {
        Write-Debug $_
        Throw $_
    }
}